
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title></title>
    
    <meta name="author" content="">
    <meta name="description" content="OpenCyto : A Robust BioConductor Framework for Automated Flow Data Analysis" />

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link href="/assets/themes/gh-slate/css/stylesheet.css" rel="stylesheet" type="text/css" media="all">

    <!-- atom & rss feed -->
    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>

  <body>
    
<div id="header_wrap" class="outer">
  <header class="inner">
    <a id="forkme_banner" href="https://github.com/" target="_blank">View on GitHub</a>

    <h1 id="project_title"><a href="index.html" style="color:rgb(255,255,255)"><font color="FFFFFF">OpenCyto</font></a></h1>
<br>
    <h2 id="project_tagline">A Robust BioConductor Framework for Automated Flow Data Analysis
</h2>

    
  </header>
</div>

    <div id="main_content_wrap" class="outer">
  <section id="main_content" class="inner">
    <!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{An Introduction to the openCyto package}
-->
<h1 id="an_introduction_to_the_opencyto_framework">An Introduction to the OpenCyto Framework</h1>

<p>The <strong>OpenCyto</strong> framework is a collection of <a href="http://www.bioconductor.org/">BioConductor</a> packages built to provide the necessary infrastructure for flow cytometry data analysis.</p>

<p>These packages include:</p>

<ul>
<li><a href="http://www.bioconductor.org/packages/2.14/bioc/html/flowCore.html">flowCore</a></li>

<li><a href="http://www.bioconductor.org/packages/2.14/bioc/html/flowViz.html">flowViz</a></li>

<li><a href="http://www.bioconductor.org/packages/2.14/bioc/html/flowStats.html">flowStats</a></li>

<li><a href="http://www.bioconductor.org/packages/2.14/bioc/html/ncdfFlow.html">ncdfFlow</a></li>

<li><a href="http://www.bioconductor.org/packages/2.14/bioc/html/flowWorkspace.html">flowWorkspace</a></li>

<li><a href="http://www.bioconductor.org/packages/2.14/bioc/html/openCyto.html">openCyto</a></li>
</ul>

<p><strong>flowCore</strong> is the core infrastructure pacakge for reading FCS files.</p>

<p><strong>flowViz</strong> handles visualization of FCS data, cell populations, and gates.</p>

<p><strong>flowStats</strong> provides some statistical methods for performing flow data normalization and gating.</p>

<p><strong>ncdfFlow</strong> implements an <strong>HDF5</strong> back-end compatible with <strong>NetCDF</strong> (Network Common Data Format) files, allowing the <em>core</em> flow packages to handle large data sets without requiring large amounts of RAM.</p>

<p><strong>flowWorkspace</strong> implements the <em>GatingHierarchy</em> and <em>GatingSet</em> data structures, which represent gated cell populations and the hierarchical relationships between them. It also implements <em>parsers</em> for <em>FlowJo</em> workspace files, allowing manually gated data to be imported into <em>R</em> and the analysis reproduced.</p>

<p>The <strong>openCyto</strong> package abstracts away the data and allows users to specify <em>gating templates</em> by defining <em>trees</em> of <em>cell populations</em>, <em>markers</em>, and the <em>gating algorithms</em> used to identify them. <em>Gates</em> themselves are defined in a <strong>data-driven</strong> manner once the template is applied to a data set.</p>

<p>When data are well-standardized (i.e. have consistent staining panels, and consistent naming of markers and channels), <strong>OpenCyto</strong> templates are <em>reusable</em>. Once defined for a particular staining panel, they can be reused on other data sets using the same panel, naming schemes, reagents, and so forth.</p>

<p>We’ll show how <strong>OpenCyto</strong> can be used to import manual gates from a <strong>FlowJo</strong> workspace and perform some visualization.</p>

<p>Then we’ll generate a <em>gating template</em> to reproduce the manual analysis and visualize those results.</p>

<h3 id="manual_gating">Manual gating</h3>

<p>Traditional gating is performed by manual inspection of pairwise dotplots. Gates are drawn by and using tools like <a href="http://www.treestart.org">FlowJo</a>.</p>

<p>Alternately, when data are well-standardized, analysts may create a set of ‘template gates’ based on the distribution of the data in one sample, and then copy these gates over to the other samples in a data set. These gates generally need to be manually inspected to ensure that they have correct placement on all samples and cell populations.</p>

<p>Both these approaches are time-consuming and subjective, and generally sub-optimal for analyzing large, high-throughput data sets such as those encountered in clinical research, or coming from new single-cell technologies like CyTOF (Mass Cytometry Time of Flight).</p>

<p>Manual gatig is also frought with problems when data are generated and analyzed at different centers (as sometimes happens in clinical trials), and the results need to be compared. Large center-to-center variability as well as bias complicated the detection of significant biological signal.</p>

<h3 id="importing_a_flowjo_workspace">Importing a FlowJo Workspace</h3>

<p>FlowJo stores a data analysis as a <em>worksapce</em>, which is just an <strong>XML</strong> document that describes the different parts of an analysis performed on a set of data; everything from compensation and transformation, to gating, and how the data are to be displayed, is represented in the workspace file.</p>

<p>The <em>flowWorkspace</em> package implements several parsers for FlowJo workspaces and supports most <strong>Windows</strong> and <strong>Mac</strong> versions of FlowJo, as well as the new <em>cross-platform</em> version X. The package imports the <em>transformations</em>, <em>compensation</em>, and <em>gates</em>, reproducing them as native <em>R</em> objects.</p>

<p>Here is one <code>xml</code> workspace from FlowJo, defining a manual gating scheme for a sample stained with a panel of T-cell markers.</p>

<pre class="r"><code class="r">
flowDataPath &lt;- system.file(&quot;extdata&quot;, package = &quot;flowWorkspaceData&quot;)
wsfile &lt;- list.files(flowDataPath, pattern = &quot;manual.xml&quot;, full = TRUE)
</code></pre>

<pre><code>
## [1] &quot;manual.xml&quot;
</code></pre>

<p>Using the <code>flowWorkspace</code> package, we open the workspace in R.</p>

<pre class="r"><code class="r">
ws &lt;- openWorkspace(wsfile)
print(ws)
</code></pre>

<p>We see that <code>ws</code> is a <code>flowJoWorksapce</code> object, with different groups of samples defined in it.<br />We call the <code>parseWorkspace</code> method to read the raw <code>FCS</code> files and apply all the compensation, transformation, and gates defined in the <code>xml</code> for the <code>&quot;T-cell&quot;</code> group of samples.</p>

<pre class="r"><code class="r">
gs &lt;- parseWorkspace(ws, name = &quot;T-cell&quot;, subset = 1, isNcdf = TRUE)
</code></pre>

<p>We now have an entire FlowJo data analysis available to us in <em>R</em>, including all the <strong>event-level</strong> data, not just the statistics.<br /><code>gs</code> is a <code>GatingSet</code> object that represents the gating hierarchy of populations.</p>

<p>We can visualize a <code>Gating Hierarchy</code> (one FCS file) from this <em>set</em>.</p>

<pre class="r"><code class="r">
gh &lt;- gs[[1]]
plot(gh)
</code></pre>

<p><img alt='plot of chunk plot-manual-GatingHierarchy' src='figure/plot-manual-GatingHierarchy.png' style='display: block; margin: auto;' title='plot of chunk plot-manual-GatingHierarchy' /></p>

<p>Specific cell populations and gates can be viewed as well, by referring to them by <em>name</em> (e.g. <code>&quot;CD3&quot;</code>), or we can just view the entire <em>layout</em>.</p>

<pre class="r"><code class="r">
plotGate(gh)
</code></pre>

<p><img alt='plot of chunk plot-manual-gates' src='figure/plot-manual-gates.png' style='display: block; margin: auto;' title='plot of chunk plot-manual-gates' /></p>

<p>The above plot shows the gating scheme for one sample from the <code>T cell</code> staining panel. If we’d like to extract the data for downstream analysis, this is also straightforward.</p>

<pre class="r"><code class="r">
head(getPopStats(gs, satistic = &quot;count&quot;))
</code></pre>

<pre><code>
##                                       CytoTrol_CytoTrol_1.fcs
## /not debris                                           0.76733
## /not debris/singlets                                  0.94878
## /not debris/singlets/CD3+                             0.62837
## /not debris/singlets/CD3+/CD4                         0.62470
## /not debris/singlets/CD3+/CD4/38+ DR+                 0.03077
## /not debris/singlets/CD3+/CD4/38+ DR-                 0.43088
</code></pre>

<p>The above gives us the <em>counts</em>. By substituting <code>statistic=&quot;freq&quot;</code>, we get the proportions. If we want the statistics that were computed by FlowJo, we pass <code>flowJo=TRUE</code>.<br />It’s not unusual for these to differ by a few cells. However, if they are vastly different, that indicates a potential problem (perhaps the XML has changed), in which case, please <a href="https://github.com/RGLab/openCyto/issues?milestone=none&state=open">contact us or file a bug report with a reproducible example</a>. We want to help.</p>

<h3 id="automated_gating">Automated Gating</h3>
<hr />
<p>We can achieve the same results as above by using the automated gating template functionality of <strong>OpenCyto</strong>.</p>

<p><code>flowCore</code>,<code>flowStats</code>,<code>flowClust</code> and other packages provides many different gating methods to detect cell sub-populations. There are <em>many</em> different methods available. <em>OpenCyto</em> doesn’t support all of them out of the box, <em>but we do provide a <a href="">plug-in framework</a></em>(Link to come), that allows users to insert support for their favorite gating algorithms.</p>

<p>The gates we do support are:</p>

<ul>
<li>quadrantGate - standard gate from flowCore</li>

<li>rangeGate - standard gate from flowCore</li>

<li>quantileGate - as the name suggests, gates on a quantile of the distribution of the data.</li>

<li>mindensity - minimum density cutpoint between two populations.</li>

<li>tailgate - gate rare cell populations by examining 1st derivative. Works well rare cytokine expressing cells.</li>

<li>cytokine - alias for tailgate.</li>

<li>flowClust - 1D, 2D, (and higher), mixture of t-distributions with Box-Cox transformations. Also supports Bayesian priors.</li>

<li>boundary - filter out boundary events.</li>

<li>singletGate - gate singlets on FSC vs SSC.</li>

<li>transitional - gates transitional B-cells.</li>

<li>polyfunctionalityGate - shortcut to gate all boolean subsets of a group of marginal gates.</li>

<li>flowDensity - via plugin. Must have flowDensity installed.</li>
</ul>

<p>These are fairly generic parametric and non-parametric approaches which can be combined in any fashion to isolate the cell populations of interest in a data set. We document them more extensively elsewhere(Link to come).</p>

<p>The <code>flowWorkspace</code> package provides the <code>GatingSet</code> as an efficient data structure to store, query and visualize the hierarchical gated data.</p>

<p>The <strong>openCyto</strong> package takes advantage of all these tools to construct a template hierarchy of cell populations, the markers that define them, the gating algorithms used to identify them, and some additional parameters to those algorithms.</p>

<h2 id="create_gating_templates">Create gating templates</h2>

<p>As previously mentioned, the template defines a tree of cell populations.</p>

<h3 id="template_format">Template format</h3>

<p>First of all, we need to describe the gating hierarchy in a spread sheet (a plain text format). This spread sheet must have the following columns:</p>

<ul>
<li><code>alias</code>: a name used label the cell population, the path composed by the alias and its precedent nodes (e.g. /root/A/B/alias) has to be uniquely identifiable.</li>

<li><code>pop</code>: population patterns of <code>A+/-</code> or <code>A+/-B+/-</code>, which tells <em>openCyto</em> which cell subset (positive or negative) of 1d gate, or which quadrant of a 2d gate isto be assigned to the <code>alias</code>.</li>

<li><code>parent</code>: the parent population (<code>pop</code>) or <code>alias</code>. The name has to be a uniquely identifiable <code>path</code> (e.g. CD4/IFNg, rather than just IFNg, if there is an IFNg gate below both CD4 and CD8).</li>

<li><code>dims</code>: marker names seperated by commas, specifying the dimensions (in 1d or 2d) used for gating. These can be either channel names or marker names.</li>

<li><code>gating_method</code>: the name of the gating function (e.g. <code>flowClust</code>). It is invoked by a wrapper function that has the identical function name prefixed with a dot (e.g. <code>.flowClust</code>). If you write a <em>plug-in</em>, you’ll be writing this wrapper function.</li>

<li><code>gating_args</code>: the named arguments passed to gating function. This will be some of the only R-code-like stuff you’ll need to write.</li>

<li><code>collapseDataForGating</code>: When <code>TRUE</code>, data is collapsed (within groups if <code>groupBy</code> specified) before gating and the gate is replicated across collapsed samples.<br />When set <code>FALSE</code> (or blank), then the <code>groupBy</code> argument is only used by preprocessing and ignored by gating.</li>

<li><code>groupBy</code>: If given, samples are split into groups by the unique combinations of study variables entered here (i.e. defined as column names of <code>pData</code>, the <code>@phenoData</code> slot of the <code>GatingSet</code>, e.g.<code>“PTID:VISITNO”</code>). This is a good reason to annotate your samples. When <code>groupBy</code> is numeric, then samples are grouped by every N samples</li>

<li><code>preprocessing_method</code>: the name of the preprocessing function (e.g. <code>prior_flowClust</code>). It is invoked by a wrapper function that has the identical function name prefixed with a dot (e.g. <code>.prior_flowClust</code>). Some methods need to preprocess the data in some way before gating. For example <code>flowClust</code> will group samples as specified and compute a prior to invode a Bayesian model fitting of the data. This helps with noisy and rare cell populations. The preprocessing results are passed to the gating wrapper function through the <code>pps_res</code> argument.</li>

<li><code>preprocessing_args</code>: the named arguments passed to preprocessing function.</li>
</ul>

<p>While that’s a lot of information, we’ll give some examles next.</p>

<h3 id="example_template">Example template</h3>

<p>Here is the an example of the gating template for the T-cell panel.</p>

<pre class="r"><code class="r">
library(openCyto)
library(data.table)
gtFile &lt;- system.file(&quot;extdata/template_tcell.csv&quot;, package = &quot;openCyto&quot;)
dtTemplate &lt;- fread(gtFile)
dtTemplate
</code></pre>

<pre><code>
##             alias              pop    parent        dims gating_method
##  1:     nonDebris        nonDebris      root       FSC-A    mindensity
##  2:      singlets         singlets nonDebris FSC-A,FSC-H   singletGate
##  3:         lymph            lymph  singlets FSC-A,SSC-A     flowClust
##  4:           cd3              cd3     lymph         CD3    mindensity
##  5:             *     cd4-/+cd8+/-       cd3     cd4,cd8    mindensity
##  6: activated cd4        CD38+HLA+  cd4+cd8-    CD38,HLA      tailgate
##  7: activated cd8        CD38+HLA+  cd4-cd8+    CD38,HLA      tailgate
##  8:      CD45_neg          CD45RA-  cd4+cd8-      CD45RA    mindensity
##  9:     CCR7_gate            CCR7+  CD45_neg        CCR7     flowClust
## 10:             * CCR7+/-CD45RA+/-  cd4+cd8- CCR7,CD45RA       refGate
## 11:             * CCR7+/-CD45RA+/-  cd4-cd8+ CCR7,CD45RA    mindensity
##               gating_args collapseDataForGating groupBy
##  1:                                                  NA
##  2:                                                  NA
##  3: K=2,target=c(1e5,5e4)                            NA
##  4:                                        TRUE       4
##  5:     gate_range=c(1,3)                            NA
##  6:                                                  NA
##  7:                                                  NA
##  8:     gate_range=c(2,3)                            NA
##  9:           neg=1,pos=1                            NA
## 10:    CD45_neg:CCR7_gate                            NA
## 11:                                                  NA
##     preprocessing_method preprocessing_args
##  1:                                      NA
##  2:                                      NA
##  3:      prior_flowClust                 NA
##  4:                                      NA
##  5:                                      NA
##  6:                                      NA
##  7:                                      NA
##  8:                                      NA
##  9:                                      NA
## 10:                                      NA
## 11:                                      NA
</code></pre>

<p>Each row is generally corresponds to one cell population and the gating method that is used to define that population.</p>

<p>We will explain how to create this gating template from the manual gating scheme, row by row.</p>

<h4 id="nondebris">“nonDebris”</h4>

<pre class="r"><code class="r">
dtTemplate[1, ]
</code></pre>

<pre><code>
##        alias       pop parent  dims gating_method gating_args
## 1: nonDebris nonDebris   root FSC-A    mindensity            
##    collapseDataForGating groupBy preprocessing_method preprocessing_args
## 1:                            NA                                      NA
</code></pre>

<ul>
<li>The population name is <code>&quot;nonDebris&quot;</code> (specified in <code>alias</code> field).</li>

<li>The <code>parent</code> node is <code>root</code> (which is always the first node of a <code>gating hierarchy</code>).</li>

<li>We use the <code>mindensity</code> method (one of the <code>gating</code> functions provided by the <code>openCyto</code> package) as <code>gating_method</code> on the <code>FSC-A</code> dimension (<code>dim</code>).</li>

<li>OpenCyto will examine the data and will generate a 1d gate on <code>FSC-A</code>. The entry in the <code>pop</code> field is <code>&quot;nonDebris&quot;</code> which is equivalent to <code>&quot;nonDebris+&quot;</code>, and indicates that we want to keep the positive part of the gate.</li>

<li>There is no <code>grouping</code> or <code>preprocessing</code> involved in this gate, thus the other columns are <code>blank</code>.</li>
</ul>

<h4 id="singlets">“singlets”</h4>

<pre class="r"><code class="r">
dtTemplate[2, ]
</code></pre>

<pre><code>
##       alias      pop    parent        dims gating_method gating_args
## 1: singlets singlets nonDebris FSC-A,FSC-H   singletGate            
##    collapseDataForGating groupBy preprocessing_method preprocessing_args
## 1:                            NA                                      NA
</code></pre>

<ul>
<li>The population name is <code>&quot;singlets&quot;</code> (<code>alias</code> field).</li>

<li>The <code>parent</code> node is <code>nonDebris</code>.</li>

<li><code>gating_method</code> is <code>singletGate</code> (provided by the <code>flowStats</code> package)</li>

<li><em>OpenCyto</em> will generate a <code>polygonGate</code> for each sample on <code>FSC-A</code> and <code>FSC-H</code> (specified by <code>dims</code>).</li>

<li>Again, <code>&quot;singlets&quot;</code> in the <code>pop</code> field represents the population <code>&quot;singlets+&quot;</code>. Here we are referring to a 2d gate, so we keep the events inside the resulting polygon.</li>
</ul>

<h4 id="lymphocyte">“lymphocyte”</h4>

<pre class="r"><code class="r">
dtTemplate[3, ]
</code></pre>

<pre><code>
##    alias   pop   parent        dims gating_method           gating_args
## 1: lymph lymph singlets FSC-A,SSC-A     flowClust K=2,target=c(1e5,5e4)
##    collapseDataForGating groupBy preprocessing_method preprocessing_args
## 1:                            NA      prior_flowClust                 NA
</code></pre>

<ul>
<li>Similarly, <code>alias</code> specifies the name of population</li>

<li>The <code>parent</code> is the <code>singlets</code> population.</li>

<li>We are going to use <code>flowClust</code> as <code>gating_method</code> to do the 2-dimensional gating. The <code>dims</code> specifies two dimensions, the <code>x</code> axis (<code>FSC-A</code>) first, and the <code>y</code> axis (<code>SSC-A</code>) second. <br />The order doesn’t affect the gating process but will determine how the gates are displayed.</li>

<li>All the parameters that the <code>flowClust</code> algorithm accepts can be put in <code>gating-args</code> as if they are typed in <code>R console</code>. see <code>help(flowClust)</code> for more details of these arguments</li>

<li>The <code>flowClust</code> algorithm also accepts and extra argument, <code>prior</code> that is calculated during <code>preprocessing</code> stage (before the gating). We supply the <code>preprocessing_method</code> as <code>prior_flowClust</code>.</li>
</ul>

<h4 id="cd3">“cd3+”</h4>

<pre class="r"><code class="r">
dtTemplate[4, ]
</code></pre>

<pre><code>
##    alias pop parent dims gating_method gating_args collapseDataForGating
## 1:   cd3 cd3  lymph  CD3    mindensity                              TRUE
##    groupBy preprocessing_method preprocessing_args
## 1:       4                                      NA
</code></pre>

<p>This is similar to the <code>nonDebris</code> gate except that we specify <code>collapseDataForGating</code> as <code>TRUE</code>, which tells the pipeline to <code>collapse</code> all samples into one and apply the <code>mindensity</code> gating method to the collapsed data on the <code>CD3</code> dimension. Once the gate is generated, it is replicated across all samples. This is particularly useful when each individual sample does not have enough events to infer the location. Here we apply this approach for expository purposes.</p>

<h4 id="cd4_and_cd8">CD4 and CD8</h4>

<p>The fourth row specifies <code>pop</code> as <code>cd4+/-cd8+/-</code>, which will be expanded into 6 rows. Specifying a population in this manner is a shortcut for defining a quadrant gate.</p>

<pre class="r"><code class="r">
dtTemplate[5, ]
</code></pre>

<pre><code>
##    alias          pop parent    dims gating_method       gating_args
## 1:     * cd4-/+cd8+/-    cd3 cd4,cd8    mindensity gate_range=c(1,3)
##    collapseDataForGating groupBy preprocessing_method preprocessing_args
## 1:                            NA                                      NA
</code></pre>

<p>The first two rows are two 1d gates that will be generated by <code>gating_method</code> on each dimension (<code>cd4</code> and <code>cd8</code>) independently:</p>

<pre><code>
##   alias  pop                        parent dims gating_method
## 5  cd4+ cd4+ /nonDebris/singlets/lymph/cd3  cd4    mindensity
## 6  cd8+ cd8+ /nonDebris/singlets/lymph/cd3  cd8    mindensity
##         gating_args collapseDataForGating groupBy preprocessing_method
## 5 gate_range=c(1,3)                                                   
## 6 gate_range=c(1,3)                                                   
##   preprocessing_args
## 5                   
## 6
</code></pre>

<p>Then another 4 rows are 4 <code>rectangleGate</code>s that corresponds to the 4 <code>quadrants</code> in 2d projection (<code>cd4 vs cd8</code>).</p>

<pre><code>
##       alias      pop                        parent    dims gating_method
## 7  cd4+cd8+ cd4+cd8+ /nonDebris/singlets/lymph/cd3 cd4,cd8       refGate
## 8  cd4-cd8+ cd4-cd8+ /nonDebris/singlets/lymph/cd3 cd4,cd8       refGate
## 9  cd4+cd8- cd4+cd8- /nonDebris/singlets/lymph/cd3 cd4,cd8       refGate
## 10 cd4-cd8- cd4-cd8- /nonDebris/singlets/lymph/cd3 cd4,cd8       refGate
##                                                              gating_args
## 7  /nonDebris/singlets/lymph/cd3/cd4+:/nonDebris/singlets/lymph/cd3/cd8+
## 8  /nonDebris/singlets/lymph/cd3/cd4+:/nonDebris/singlets/lymph/cd3/cd8+
## 9  /nonDebris/singlets/lymph/cd3/cd4+:/nonDebris/singlets/lymph/cd3/cd8+
## 10 /nonDebris/singlets/lymph/cd3/cd4+:/nonDebris/singlets/lymph/cd3/cd8+
##    collapseDataForGating groupBy preprocessing_method preprocessing_args
## 7                                                                       
## 8                                                                       
## 9                                                                       
## 10
</code></pre>

<p>As we see here, <code>&quot;refGate&quot;</code> in <code>gating_method</code> indicates that they are constructed based on the <code>gate coordinates</code> of the two previous 1d gates. Those 1d gates are thus considered as <code>&quot;reference gates&quot;</code> that are referred by colon separated <code>alias</code> string in <code>gating_args</code>: <code>&quot;cd4+:cd8+&quot;</code>.</p>

<p>Alternatively, we can expand it into these 6 rows explicitly in the spread sheet. But this convenient representation is recommended unless user wants have finer control on how the gating is done. For instance, sometime we need to use different <code>gating_method</code>s to generate 1d gates on <code>cd4</code> and <code>cd8</code>. Or <code>cd8</code> gating needs to depend on <code>cd4</code> gating ,i.e. the <code>parent</code> of <code>c8+</code> is <code>cd4+</code>(or <code>cd4-</code>) instead of <code>cd3</code>. Sometimes we want to have the customized <code>alias</code> other than quadrant-like name (<code>x+y+</code>) that gets generated automatically. (e.g. 5th row of the gating template)</p>

<h2 id="loading_a_gating_template">Loading a gating template</h2>

<p>After the gating template is defined in the spread sheet, it can be loaded into R:</p>

<pre class="r"><code class="r">
gt_tcell &lt;- gatingTemplate(gtFile)
</code></pre>

<pre><code>
## Adding population: nonDebris 
## Adding population: singlets 
## Adding population: lymph 
## Adding population: cd3 
## Adding population: cd4+ 
## Adding population: cd8+ 
## Adding population: cd4+cd8+ 
## Adding population: cd4-cd8+ 
## Adding population: cd4+cd8- 
## Adding population: cd4-cd8- 
## Adding population: CD38+ 
## Adding population: HLA+ 
## Adding population: activated cd4 
## Adding population: CD38+ 
## Adding population: HLA+ 
## Adding population: activated cd8 
## Adding population: CD45_neg 
## Adding population: CCR7_gate 
## Adding population: CCR7+CD45RA+ 
## Adding population: CCR7-CD45RA+ 
## Adding population: CCR7+CD45RA- 
## Adding population: CCR7-CD45RA- 
## Adding population: CCR7+ 
## Adding population: CD45RA+ 
## Adding population: CCR7+CD45RA+ 
## Adding population: CCR7-CD45RA+ 
## Adding population: CCR7+CD45RA- 
## Adding population: CCR7-CD45RA-
</code></pre>

<pre class="r"><code class="r">
gt_tcell
</code></pre>

<pre><code>
## --- Gating Template: default
## 	with  29  populations defined
</code></pre>

<p>We can further examine the template by visualizing it:</p>

<pre class="r"><code class="r">
plot(gt_tcell)
</code></pre>

<p><img alt='plot of chunk plot-gt' src='figure/plot-gt.png' style='display: block; margin: auto;' title='plot of chunk plot-gt' /></p>

<p>The gating scheme for CD4 and CD8 T-cell subsets has been expanded as we described above. All the <strong>colored</strong> arrows source from the <code>parent</code> population and the <strong>grey</strong> arrows source from <code>reference</code> populations.</p>

<h2 id="run_the_gating_pipeline">Run the gating pipeline</h2>

<p>Once we are satisfied with the gating template, we can apply it to flow data.</p>

<h3 id="load_the_raw_data">Load the raw data</h3>

<p>First of all, we load the raw FCS files into R by <code>ncdfFlow::read.ncdfFlowSet</code> (It uses less memory than <code>flowCore::read.flowSet</code>).</p>

<pre class="r"><code class="r">
fcsFiles &lt;- list.files(pattern = &quot;CytoTrol&quot;, flowDataPath, full = TRUE)
ncfs &lt;- read.ncdfFlowSet(fcsFiles)
ncfs
</code></pre>

<pre><code>
## An ncdfFlowSet with 2 samples.
## flowSetId :  
## NCDF file : /var/folders/d8/r559697j43g0nttnt03rvfp00000gn/T//Rtmp2ahMtZ/ncfs15ee15fc83dab.nc 
## An object of class &#39;AnnotatedDataFrame&#39;
##   rowNames: CytoTrol_CytoTrol_1.fcs CytoTrol_CytoTrol_2.fcs
##   varLabels: name
##   varMetadata: labelDescription
## 
##   column names:
##     FSC-A, FSC-H, FSC-W, SSC-A, B710-A, R660-A, R780-A, V450-A, V545-A, G560-A, G780-A, Time
</code></pre>

<h3 id="compensation">Compensation</h3>

<p>Then, we compensate the data. If we have compensation controls (i.e. single stained samples), we can calculate the compensation matrix by <code>flowCore::spillover</code> function. Here we simply use the compensation matrix defined in <code>flowJo workspace</code>.</p>

<pre class="r"><code class="r">
compMat &lt;- getCompensationMatrices(gh)
ncfs_comp &lt;- compensate(ncfs, compMat)
</code></pre>

<pre><code>
## [1] &quot;copying data slice: CytoTrol_CytoTrol_1.fcs&quot;
## [1] &quot;copying data slice: CytoTrol_CytoTrol_2.fcs&quot;
</code></pre>

<p>Here is one example showing the compensation outcome: <img alt='plot of chunk compensate_plot' src='figure/compensate_plot.png' style='display: block; margin: auto;' title='plot of chunk compensate_plot' /></p>

<h3 id="43_transformation">4.3. Transformation</h3>

<p>All the stained channels need to be transformed properly before the gating. Here we use the <code>flowCore::estimateLogicle</code> to do the <code>logicle</code> transformation.</p>

<pre class="r"><code class="r">
chnls &lt;- parameters(compMat)
transFuncts &lt;- estimateLogicle(ncfs[[1]], channels = chnls)
ncfs_trans &lt;- transform(ncfs_comp, transFuncts)
</code></pre>

<pre><code>
## [1] &quot;copying data slice: CytoTrol_CytoTrol_1.fcs&quot;
## [1] &quot;copying data slice: CytoTrol_CytoTrol_2.fcs&quot;
</code></pre>

<p>Here is one example showing the transformation outcome: <img alt='plot of chunk transformation_plot' src='figure/transformation_plot.png' style='display: block; margin: auto;' title='plot of chunk transformation_plot' /></p>

<h3 id="create_gatingset">Create ‘GatingSet’</h3>

<p>Once the data is preprocessed, it can be loaded into a <code>GatingSet</code> object.</p>

<pre class="r"><code class="r">
gs &lt;- GatingSet(ncfs_trans)
getNodes(gs[[1]])
</code></pre>

<pre><code>
## [1] &quot;root&quot;
</code></pre>

<p>As <code>getNodes</code> shows, there is only one population node at this point (<code>root</code>).</p>

<h3 id="gating">Gating</h3>

<p>Now we can apply the gating template to the data:</p>

<pre class="r"><code class="r">
gating(gt_tcell, gs)
</code></pre>

<p>Optionally, we can run the pipeline in <code>parallel</code> to speed up gating. e.g.</p>

<pre class="r"><code class="r">
gating(gt_tcell, gs, mc.cores = 2, parallel_type = &quot;multicore&quot;)
</code></pre>

<h3 id="hide_nodes">Hide nodes</h3>

<p>After gating, there are some extra populations generated automatically by the pipeline (e.g. <code>refGate</code>).</p>

<pre class="r"><code class="r">
plot(gs[[1]])
</code></pre>

<p><img alt='plot of chunk plot_afterGating' src='figure/plot_afterGating.png' style='display: block; margin: auto;' title='plot of chunk plot_afterGating' /></p>

<p>We can hide these populations if we are not interested in them:</p>

<pre class="r"><code class="r">
nodesToHide &lt;- c(&quot;cd8+&quot;, &quot;cd4+&quot;, &quot;cd4-cd8-&quot;, &quot;cd4+cd8+&quot;, &quot;cd4+cd8-/HLA+&quot;, &quot;cd4+cd8-/CD38+&quot;, 
    &quot;cd4-cd8+/HLA+&quot;, &quot;cd4-cd8+/CD38+&quot;, &quot;CD45_neg/CCR7_gate&quot;, &quot;cd4+cd8-/CD45_neg&quot;, 
    &quot;cd4-cd8+/CCR7+&quot;, &quot;cd4-cd8+/CD45RA+&quot;)
lapply(nodesToHide, function(thisNode) setNode(gs, thisNode, FALSE))
</code></pre>

<h3 id="rename_nodes">Rename nodes</h3>

<p>We can rename some populations to be more ‘friendly’:</p>

<pre class="r"><code class="r">
setNode(gs, &quot;cd4+cd8-&quot;, &quot;cd4&quot;)
setNode(gs, &quot;cd4-cd8+&quot;, &quot;cd8&quot;)
</code></pre>

<h3 id="visualization">Visualization</h3>

<pre class="r"><code class="r">
plot(gs[[1]])
</code></pre>

<p><img alt='plot of chunk plot_afterHiding' src='figure/plot_afterHiding.png' style='display: block; margin: auto;' title='plot of chunk plot_afterHiding' /></p>

<p>And finally we plot the gated data.</p>

<pre class="r"><code class="r">
plotGate(gs[[1]])
</code></pre>

<p><img alt='plot of chunk plotGate_autoGate' src='figure/plotGate_autoGate.png' style='display: block; margin: auto;' title='plot of chunk plotGate_autoGate' /></p>

<h2 id="conclusion">Conclusion</h2>

<p>The <code>openCyto</code> package allows user to specify their gating schemes and gate the data in a data-driven fasion. It frees the data analysts from the labor-intensitive manual gating routines and increases the speed as well as the reproducibilty and objectivity of the data analysis work. A gating template, as defined above, could be applied to any flow data that uses the same markers, coming off the same instrument. Given the same template and data, anyone could reproduce this same analysis.</p>
  </section>
</div>

    <div id="footer_wrap" class="outer">
  <footer class="inner">
    <p class="copyright">OpenCyto maintained by <a href="https://github.com/RGLab">RGLab</a></p>
    <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
  </footer>
</div>


    
  </body>
</html>

