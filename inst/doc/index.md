<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{An Introduction to the openCyto package}
-->

An Introduction to **openCyto** package
=======================================


```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(out.extra='style="display:block; margin: auto"', fig.align="center")
```


Introduction
------------


The  **openCyto** package is designed to facilitate the automated gating methods in sequential way to mimic the manual gating scheme.


Traditional way of Gating (manually)
----------------------------
Biologists have to draw the gates for each individual sample on each 2D projections (2 channels) within `flowJo`. 
Or draw the 'template gate's on one sample and replicate it to other samples, then manually inspect the gate on each sample
to do the correction if necessary. Either way is time consuming and subjective, thus not suitable for the large data sets
generated by high-throughput flow Cytometers or the `cross-lab` data analysis.   

Here is one `xml` workspace (manual gating scheme) exported from `flowJo`.
```{r load-xml, eval=F}
library(flowWorkspace)
wsfile <- list.files(system.file("extdata", package="flowWorkspaceData"), pattern="manual.xml",full = TRUE)
wsfile
```
By using`flowWorkspace`package, We can load it into R,
```{r openWorkspace, eval=F}
ws <- openWorkspace(wsfile)
```
apply (`parseWorkspace`) the`manual gates`defined in`xml`to the raw`FSC`files,
```{r parseWorkspace, eval=F}
gs <- parseWorkspace(ws, name= "T-cell", subset =1)
```
and then visualize the`Gating Hierarchy` 
```{r plot-manual-GatingHierarchy, eval=F}
gh <- gs[[1]]
plot(gh)
```
and the`gates`: 
```{r plot-manual-gates, eval=F}
plotGate(gh, xbin = 32)
```   
This is a gating scheme for `T cell` panel, which tries to identify `T cell` sub-populations.
We can achieve the same results by using automated gating pipeline provided by this package.

Automated Gating methods
-----------------------------
`flowCore`,`flowStats`,`flowClust` and other packages provides many different gating methods to 
detect cell populations and draw the gates automatically. 

`flowWorkspace` package provides the `GatingSet` as an efficient data structure to store, query and visualize the hierarchical gated data.

By taking advantage of these tools, `openCyto` package can create the automated gating pipeline by a `gating template`, which is essentially the same kind of hierarchical gating scheme 
used by the biologists and scientists.
  

Create gating templates
-----------------------------
First of all, we need to describe the gating hierarchy in a spread sheet (a plain text format).
This spread sheet must have the following columns:
* 'alias': a name used label the cell population, the path composed by the alias and its precedent nodes (e.g. /root/A/B/alias) has to be uniquely identifiable.
* 'pop': population patterns of 'A+/-` or 'A+/-B+/-', which tells the algorithm which side (postive or negative) of 1d gate or which quadrant of 2d gate to be kept
* 'parent': the parent population alias, its path has to be uniquely identifiable.
* 'dims': characters seperated by comma specifying the dimensions(1d or 2d) used for gating. It can be either channel name or stained marker name.
* 'gating_method': the name of the gating function (e.g. 'flowClust'). It is invoked by a wrapper function that has the identical function name prefixed with a dot.(e.g. '.flowClust')
* 'gating_args': the named arguments passed to gating function
* 'collapseDataForGating': When TRUE, data is collapsed (within groups if 'groupBy' specified) before gating and the gate is replicated across collapsed samples.
  When set FALSE (or blank),then 'groupBy' argument is only used by 'preprocessing' and ignored by gating.
* 'groupBy': If given, samples are split into groups by the unique combinations of study variable (i.e. column names of pData,e.g."PTID:VISITNO").
  when split is numeric, then samples are grouped by every N samples 
* 'preprocessing_method': the name of the preprocessing function(e.g. 'prior_flowClust'). It is invoked by a wrapper function that has the identical function name prefixed with a dot.(e.g. '.prior_flowClust')
  the preprocessing results are then passed to gating wrapper function through 'pps_res' argument.
* 'preprocessing_args': the named arguments passed to preprocessing function.

Here is the an example of the gating template.
```{r gatingTemplate, eval = T}
library(openCyto)
library(data.table)
gtFile <- system.file("extdata/Cytotrol_Tcell.csv", package = "openCyto")
dtTemplate <- fread(gtFile)
dtTemplate
```
Each row is usually corresponding to one cell population and the gating method that is used to get that population.
For example, the first row describes how to get `nonDebris` population:
```{r gatingTemplate-nonDebris, eval = T}
dtTemplate[1,]
```  
* The population name is `"nonDebris"` (specified in `alias` field).
* The `parent` node is `root` (which is always the first node of `gating hierarchy` by default). 
* We use `mindensity` (one of the `gating` functions provided by `openCyto` package) as `gating_method` to gate on dimension (`dim`) of `FSC-A`.
* As the result, it will generate a 1d gate on `FSC-A`. `"nonDebris"` (equivalent to `"nonDebris+"`) in `pop` field indicates the 
`positive` side of 1d gate is kept as the population of interest. 
* There is no `grouping` or `preprocessing` involved in this gate, thus leave the other columns as `blank`

The second row describes how to gate out the `lymphocyte` population from `nonDebris` that is the result of the first gating step.
```{r gatingTemplate-lympth, eval = T}
dtTemplate[2,]
```
* Similarly, `alias` specifies the name of population;
* `parent` points to `nonDebris`
* Since we are going to use `flowClust` as `gating_method` to do the 2-dimensional gating,
	`dims` is comma separated string, `x` axis (`FSC-A`) goes first, `y` (`SSC-A`) the second. 
	This order doesn't affect the gating process but will determine how the gates are displayed.     
* All the parameters that `flowClust` algorithm accepts can be put in `gating-args` as if they are typed in `R console`.
	see `help(flowClust)` for more details of these arguments
* `flowClust` algorithm accept the extra arguments `priors` that is calculated during `preprocessing` stage (before the actual `gating`),
	thus, we supply the `preprocessing_method` with `prior_flowClust`.
* Again, `"lymph"` in `pop` field stands for `"lymph+"`. But here it is 2d gate (`polygonGate`),  which means we want to keep the area inside of the polygon

The third row describes the gating of `cd3+` (Tcell),
```{r gatingTemplate-cd3, eval = T}
dtTemplate[3,]
```
It is similar to the `nonDebris` gate except that we specify `collapseDataForGating` as `TRUE`, 
which tells the pipeline to `collapse` all samples into one and applies `mindensity` to the collapsed data on `CD3` dimension.
Once the gate is generated, it is replicated across all samples. This is only useful when each individual sample does not have
enough events to deduce the gate. Here we do this just for the purpose of proof of concept. 

The forth row is a little different in terms of `pop` pattern. 
```{r gatingTemplate-cd3, eval = T}
dtTemplate[4,]
```
As we see, instead of the regular   
  	 	
```{r csv, eval = T}
gt_tcell <- gatingTemplate(gtFile)
plot(gt1)
getNodes(gs1[[1]])
Rm("cd3",gs1)
load(file.path(path,"data/fs_tcell.rda"))
gs1<-GatingSet(fs_tcell)
env1<-new.env(parent=emptyenv())
gating(gt1,gs1,env1,mc.cores=4,parallel_type = "multicore")
plotGate(gs1[[1]],xbin=32)
plot(env1$fct,"nonDebris",post=T)
plot(env1$fct,"cd3",post=T)
plot(env1$fct,"cd4+",post=T,channel="<B710-A>")
plot(env1$fct,"activated cd4",post=T,channel="<R660-A>")
plot(env1$fct,2,post=T)
plot(env1$fct,"lymph",post=T)
```









